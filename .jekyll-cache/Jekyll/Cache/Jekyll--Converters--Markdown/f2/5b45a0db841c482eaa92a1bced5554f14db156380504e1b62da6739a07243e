I"O$<p>Sorting algorithms can be used to handle several problems, including:</p>
<ul>
  <li>searching</li>
  <li>selection</li>
  <li>duplicates</li>
  <li>distribution</li>
</ul>

<p>This post presents notes on the following algorithms, along with links to their implementations:</p>
<ul>
  <li><a href="#Bubble-Sort">Bubble Sort</a></li>
  <li><a href="#Insertion-Sort">Insertion Sort</a></li>
  <li><a href="#Merge-Sort">Merge Sort</a></li>
  <li><a href="#Quick-Sort">Quick Sort</a></li>
  <li><a href="#Timsort">Timsort</a></li>
</ul>

<p>An overview of the algorithms, in terms of time and implementation complexity, is shown in the table below:</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Time Complexity</th>
      <th>Implementation Complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bubble Sort</td>
      <td>O(n^2)</td>
      <td>Simple</td>
    </tr>
    <tr>
      <td>Insertion Sort</td>
      <td>O(n^2)</td>
      <td>Simple</td>
    </tr>
    <tr>
      <td>Merge Sort</td>
      <td>O(n log_2 n)</td>
      <td>Intermediate</td>
    </tr>
    <tr>
      <td>Quick Sort</td>
      <td>O(n log_2 n)</td>
      <td>Intermediate</td>
    </tr>
    <tr>
      <td>Timsort</td>
      <td>O(n log_2 n)</td>
      <td>Complex</td>
    </tr>
  </tbody>
</table>

<h2 id="bubble-sort">Bubble Sort</h2>
<p>Each element in a list is compared to the element to its right and they are swapped if necessary, with the larger valued element moving towards the end of the list.
Multiple passes are made through the list, with each pass resulting in the list moving closer to an order.</p>

<p>When two elements are swapped, also known as exchanged, Python can perform a simultaneous assignment, i.e. the swap can be performed in one statement:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">element</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">element</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
</code></pre></div></div>

<p>On the other hand, other languages require a temporary variable to hold one value during the swap:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">temporary</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
<span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">elements</span><span class="p">[</span><span class="n">element</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temporary</span>
</code></pre></div></div>

<p>Time complexity:</p>
<ul>
  <li>best: <strong>O(n)</strong> - requires the sorted list check optimisation</li>
  <li>average: <strong>O(n^2)</strong></li>
  <li>worst: <strong>O(n^2)</strong></li>
</ul>

<p>Characteristics:</p>
<ul>
  <li>simple to implement</li>
  <li>slow to sort</li>
</ul>

<p>View the full implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/5382ba33636a8cfae2950a5ba63dbc9744e93181/sorting/bubble_sort.py#L13">bubble sort algorithm here</a>.</p>

<h3 id="optimisations">Optimisations</h3>
<p>The bubble sort can be optimised to prevent extra unnecessary operations being performed.
This optimisation involves checking for whether the list has reached an ordered state and terminating, and is referred to as the <strong>short bubble sort</strong>.</p>

<p>View the optimised implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/5382ba33636a8cfae2950a5ba63dbc9744e93181/sorting/bubble_sort.py#L46">bubble sort algorithm here</a>.</p>

<h2 id="insertion-sort">Insertion Sort</h2>
<p>Each element in a list is taken out and compared against the elements to its left until its correct position in the list is found, at which point it is inserted back into the list.
The elements that are left of the element that is currently being sorted are ordered, with this order being maintained throughout the sort.
All elements in the ordered sublist that are greater than the element being sorted can be moved to the right, as the sorted element is first taken out of the list leaving a free slot.</p>

<p>Time complexity:</p>
<ul>
  <li>best: <strong>O(n)</strong> - when the list is already sorted</li>
  <li>average: <strong>O(n^2)</strong></li>
  <li>worst: <strong>O(n^2)</strong></li>
</ul>

<p>Characteristics:</p>
<ul>
  <li>simple to implement</li>
  <li>more efficient than quadratic algorithms, such as the bubble sort</li>
  <li>not efficient for large datasets</li>
</ul>

<p>View the full implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/master/sorting/insertion_sort.py">insertion sort algorithm here</a>.</p>

<h2 id="merge-sort">Merge Sort</h2>
<p>This algorithm uses recursion to sort a list of unordered elements.
In particular, the divide-and-conquer approach is used, which has the following structure:</p>
<ul>
  <li>break the problem into smaller sub-problems</li>
  <li>solve each sub-problem using recursion</li>
  <li>combine the solution for each solved sub-problem to form the solution</li>
</ul>

<p>The merge sort algorithm repeatedly splits a list of elements in half until only one element is left in each half, at which point each half is considered sorted.
After splitting the list, the next step is to combine the halves to form incrementally larger ordered lists.</p>

<p>Time complexity:</p>
<ul>
  <li>best: <strong>O(n log_2 n)</strong></li>
  <li>average: <strong>O(n log_2 n)</strong></li>
  <li>worst: <strong>O(n log_2 n)</strong></li>
</ul>

<p>Characteristics:</p>
<ul>
  <li>an efficient algorithm that scales to large datasets</li>
  <li>can be parallelised as it breaks the input into smaller chunks</li>
  <li>time penalty due to recursion which does not perform well with smaller datasets</li>
  <li>larger memory requirement, in comparison to other algorithms, due to copying lists</li>
</ul>

<p>View the full implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/master/sorting/merge_sort.py">merge sort algorithm here</a>.</p>

<h2 id="quick-sort">Quick Sort</h2>
<p>Quick sort is also a recursive algorithm that utilises the divide-and-conquer approach.
First, the unordered list is repeatedly split into two lists, where one holds lower-valued elements and the other holds higher valued elements.
This split is known as partitioning and is implemented by selecting a pivot value, where the position of the pivot value in the list is called the split point.
Second, the placement of elements into the two lists is performed, and the two lists are merged until the recursion is complete.</p>

<p>Time complexity:</p>
<ul>
  <li>best: <strong>O(n)</strong></li>
  <li>average: <strong>O(n log_2 n)</strong></li>
  <li>worst: <strong>O(n^2)</strong></li>
</ul>

<blockquote>
  <p>The worst case can be set to <strong>O(n log_2 n)</strong> if the pivot value is selected by finding the median value in the list. But, in practice, implementing this only has benefits when handling large datasets.</p>
</blockquote>

<p>Characteristics:</p>
<ul>
  <li>an efficient sorting algorithm</li>
  <li>can be parallelised due to it breaking the input into small chunks</li>
  <li>cannot guarantee the average time complexity of <strong>O(n log_2 n)</strong></li>
  <li>requires larger amounts of memory due to it creating new lists</li>
  <li>not efficient for smaller datasets</li>
</ul>

<p>View the full implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/master/sorting/quick_sort.py">quick sort algorithm here</a>.</p>

<h2 id="timsort">Timsort</h2>
<p>This sorting algorithm utilises both the insertion and merge sorting algorithms, resulting in a hybrid approach to ordering a list.
It takes advantage of <strong>natural runs</strong>, i.e. elements that are already sorted.
These runs are collected and then merged to form the final solution.</p>

<p>Time complexity:</p>
<ul>
  <li>best:  O(n) - lists that are close to ordered</li>
  <li>average: O(n log_2 n)</li>
  <li>worst: O(n log_2 n)</li>
</ul>

<p>Characteristics:</p>
<ul>
  <li>complex algorithm to implement</li>
  <li>performs well with small and large datasets</li>
  <li>time complexity is fairly consistent</li>
</ul>

<p>View the full implementation of the <a href="https://github.com/jonathanstaniforth/developer-notes/blob/master/sorting/timsort.py">timsort algorithm here</a>.</p>
:ET